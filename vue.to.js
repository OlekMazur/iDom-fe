#!/usr/bin/env node

/*
 * Vue template compiler
 *
 * This file is part of iDom-fe.
 *
 * Copyright (c) 2019, 2023 Aleksander Mazur
 *
 * iDom-fe is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * iDom-fe is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with iDom-fe. If not, see <https://www.gnu.org/licenses/>.
 */

const fs = require('fs')
const { glob } = require('glob')
const compiler = require('vue-template-compiler')
const transpile = require('vue-template-es2015-compiler')
//const UglifyJS = require('uglify-js')

const SRC = process.argv[2]
const OUT = process.argv[3]
if (!SRC || !OUT) {
	console.error('Usage: ' + process.argv[1].split('/').pop() + ' <srcdir> <outdir>')
	process.exit(2)
}

function print_array(array, template) {
	for (let i = 0, len = array.length; i < len; i++) {
		console.error(array[i].msg)
		const end = array[i].end || array[i].start + 1
		console.error(compiler.generateCodeFrame(template, array[i].start, end))
	}
}

function to_function(code) {
	return 'function() { ' + code + ' }'
}

/*
function beautify(code) {
	const beautiful = UglifyJS.minify(code, {
		output: {
			beautify: true,
			semicolons: false,
		},
	})
	if (beautiful.error) {
		console.warn(beautiful.error)
		return code
	}
	return beautiful.code
}
*/

glob(SRC + '/**/*.vue')
.then((files) => {
	for (let i = 0, len = files.length; i < len; i++) {
		let parts = files[i].split('/')
		if (parts.shift() != SRC) {
			console.error(files[i] + ': unexpected file matched')
			process.exitCode = 1
			return
		}
		const output = OUT + '/' + parts.join('/') + '.js'
		const origname = parts.pop()
		console.log(files[i] + ' -> ' + output)

		const template = fs.readFileSync(files[i], 'utf8')

		const compiled = compiler.compile(template, {
			outputSourceRange: true,
			whitespace: 'condense',
		})
		if (compiled.staticRenderFns && !compiled.staticRenderFns.length)
			delete compiled.staticRenderFns

		if (compiled.tips) {
			print_array(compiled.tips, template)
		}
		if (compiled.errors && compiled.errors.length) {
			print_array(compiled.errors, template)
			process.exitCode = 1
			continue
		}

		let module = ''
		module += 'const template = {\n'
		if (compiled.render)
			module += '\trender: ' + to_function(compiled.render) + ',\n'
		if (compiled.staticRenderFns) {
			module += '\tstaticRenderFns: [\n'
			for (let j = 0, jlen = compiled.staticRenderFns.length; j < jlen; j++)
				module += '\t\t' + to_function(compiled.staticRenderFns[j]) + ',\n'
			module += '\t],\n'
		}
		module += '}\n'
		module = transpile(module)
		//module = beautify(module)

		module = '// This file is automatically generated from "' + origname + '", please do not edit\n\n' + module + '\nexport default template\n'

		parts = output.split('/')
		parts.pop()
		if (parts.length)
			fs.mkdirSync(parts.join('/'), {
				recursive: true,
			})
		fs.writeFileSync(output, module, 'utf8')
	}
})
